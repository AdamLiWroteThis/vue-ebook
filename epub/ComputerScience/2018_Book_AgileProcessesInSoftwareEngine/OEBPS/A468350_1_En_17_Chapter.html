<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><title>Towards Agile Scalability Engineering</title><link href="springer_epub.css" type="text/css" rel="styleSheet"/></head><body><div class="ChapterContextInformation"><div class="ContextInformation" id="Chap17"><div class="ChapterCopyright">© The Author(s) 2018</div><span class="ContextInformationAuthorEditorNames"><span class="Editor"><span class="EditorName">Juan Garbajosa</span>, </span><span class="Editor"><span class="EditorName">Xiaofeng Wang</span> and </span><span class="Editor"><span class="EditorName">Ademar Aguiar</span></span><span class="CollaboratorDesignation"> (eds.)</span></span><span class="ContextInformationBookTitles"><span class="BookTitle" xml:lang="en">Agile Processes in Software Engineering and Extreme Programming</span></span><span class="ContextInformationSeries"><span class="SeriesTitle" xml:lang="en">Lecture Notes in Business Information Processing</span><span class="ContextInformationVolumeNumber">314</span></span><span class="ChapterDOI"><a href="A468350_1_En_17_Chapter.html">https://doi.org/10.1007/978-3-319-91602-6_17</a></span></div></div><!--Begin Abstract--><div class="MainTitleSection"><h1 class="ChapterTitle" xml:lang="en">Towards Agile Scalability Engineering</h1></div><div class="AuthorGroup"><div class="AuthorNames"><span class="Author"><span class="AuthorName">Gunnar Brataas</span><sup>1 <a href="#ContactOfAuthor1"><span class="ContactIcon"> </span></a></sup>, </span><span class="Author"><span class="AuthorName">Geir Kjetil Hanssen</span><sup>1 <a href="#ContactOfAuthor2"><span class="ContactIcon"> </span></a></sup> and </span><span class="Author"><span class="AuthorName">Georg Ræder</span><sup>2 <a href="#ContactOfAuthor3"><span class="ContactIcon"> </span></a></sup></span></div><div class="Affiliations"><div class="Affiliation" id="Aff9"><span class="AffiliationNumber">(1)</span><div class="AffiliationText">SINTEF Digital, Trondheim, Norway</div></div><div class="Affiliation" id="Aff10"><span class="AffiliationNumber">(2)</span><div class="AffiliationText">EVRY Norway AS, Fornebu, Norway</div></div><div class="ClearBoth"> </div></div><div class="Contacts"><div class="Contact" id="ContactOfAuthor1"><div class="ContactIcon"> </div><div class="ContactAuthorLine"><span class="AuthorName">Gunnar Brataas</span> (Corresponding author)</div><div class="ContactAdditionalLine"><span class="ContactType">Email: </span><a href="mailto:Gunnar.Brataas@sintef.no" class="Email">Gunnar.Brataas@sintef.no</a></div></div><div class="Contact" id="ContactOfAuthor2"><div class="ContactIcon"> </div><div class="ContactAuthorLine"><span class="AuthorName">Geir Kjetil Hanssen</span></div><div class="ContactAdditionalLine"><span class="ContactType">Email: </span><a href="mailto:Geir.K.Hanssen@sintef.no" class="Email">Geir.K.Hanssen@sintef.no</a></div></div><div class="Contact" id="ContactOfAuthor3"><div class="ContactIcon"> </div><div class="ContactAuthorLine"><span class="AuthorName">Georg Ræder</span></div><div class="ContactAdditionalLine"><span class="ContactType">Email: </span><a href="mailto:Georg.Raeder@evry.com" class="Email">Georg.Raeder@evry.com</a></div></div></div></div><div class="Abstract" id="Abs1" xml:lang="en"><div class="Heading">Abstract</div><div id="Par1" class="Para">Scalability engineering is currently not well integrated into agile development techniques. This paper extends agile development techniques so that scalability can be handled in an incremental and iterative development process. By scalability we mean the ability of a system to handle increasing workload. We propose the ScrumScale Method which includes scalability engineering in Scrum. This extension should also be applicable to other agile techniques. For scalability testing, we indicate how quality thresholds should be scaled up or down according to the degree of completeness of the product, test hardware, test software, test data and test workload. Using action research, we have conducted three pilots in three Norwegian software organizations. These three pilots have different architectures and operate in different markets yet have in common scalability challenges.
</div></div><div class="KeywordGroup" xml:lang="en"><div class="Heading">Keywords</div><span class="Keyword">Scrum</span><span class="Keyword">Software performance engineering (SPE)</span><span class="Keyword">Action research</span></div><!--End Abstract--><div class="Fulltext"><div id="Sec1" class="Section1 RenderAsSection1"><h2 class="Heading"><span class="HeadingNumber">1 </span>Introduction</h2><div id="Par2" class="Para">A scalable system can handle increasing workloads by utilizing more hardware or software resources [<cite><a href="#CR4">4</a></cite>, <cite><a href="#CR6">6</a></cite>]. A system with poor scalability is unable to extend its capacity if demanded by unexpected workloads. A costly and time-consuming redesign is required. Despite careful planning and design, scalability is still a “fragile” property that can easily be jeopardized by carelessness or problems in inter-connected systems. Hence, scalability is a pervasive property of a system.</div><div id="Par3" class="Para">Agile methods address a similar challenge. Agile methods target development projects where requirements are not fully known in advance. Using agile methods, software projects deliver parts of the solution with the intention of quickly validating whether the deliverables meet user expectations. Many software organizations are continuously challenged to reduce time to market for new solutions. Agile methods help them to scope delivered solutions so that they can rapidly adjust to unpredictable market needs.</div><div id="Par4" class="Para">At present, we lack conceptually sound approaches to incorporating scalability engineering into agile software development. Many software organizations are faced with a difficult balancing act when trying to accommodate both. Scalability is a property of a system that accentuates the tensions between planning and agility to a new level. Both scalability and agility seek to accommodate uncertainty. Both scalability and agility are important to meeting the needs for software organizations’ competitiveness. It is therefore imperative that we find solutions to how scalability and agility can be combined.</div><div id="Par5" class="Para">Babar et al. advocate a middle ground between agile development and incorporating elements of up-front planning [<cite><a href="#CR1">1</a></cite>]. We seek to develop more powerful concepts for dealing with scalability to assist stakeholders and practitioners in their collaboration on scalability engineering. In particular, we think that a more effective language for scalability will assist in enabling collaboration among product owners, architects, developers and testers on the construction of sound scalability requirements. Scalability testing can be put to use in a more agile working practice where it contributes to produce continuous feedback.</div><div id="Par6" class="Para">We are in the middle of the ScrumScale project that seeks to resolve this challenge. The main objective of the ScrumScale project is to reduce the cost of handling scalability using agile development practices. This cost may be reduced in three ways: (1) Using care when developing software so that costly and time-consuming redesign is reduced. (2) Less gold-plating of subsystems that scale “too well,” to reduce development costs. (3) Reduced consumption of hardware (CPUs, disks, networks) and software resources (with license and cloud service fees) as a result of improved scalability.</div><div id="Par7" class="Para">The main result of ScrumScale will be an extension of agile techniques to accommodate scalability. We have started with Scrum, but these extensions should also be applicable to other agile techniques. The main contribution of this paper is a Scrum-based process for how to handle scalability in Sect. <span class="InternalRef"><a href="#Sec2">2</a></span>. For scalability testing, we indicate how quality thresholds should be scaled up or down according to the degree of completeness of the product, test hardware, test software, test data and test workload. In Sect. <span class="InternalRef"><a href="#Sec8">3</a></span>, conclusions and further work are outlined.</div><div id="Par8" class="Para">ScrumScale adopts the action research paradigm where researchers and practitioners seek to solve problems in collaboration using cycles of the steps diagnosis, planning, intervention, evaluation and reflection [<cite><a href="#CR5">5</a></cite>]. In addition to the research partner SINTEF, ScrumScale has the three industrial partners EVRY, Powel and Altinn. EVRY delivers financial services solutions, Powel energy and public software solutions with related services, while Altinn is the largest Norwegian public portal.</div><div id="Par9" class="Para">We have completed the first pilot phase with one pilot for each industrial partner. These pilots differ both in scope, domain as well as duration. Common to all these three pilots were anticipated scalability challenges. The initial diagnosis before starting these three pilots showed that the root cause of problematic scalability was vague scalability requirements [<cite><a href="#CR2">2</a></cite>]. Clarifying scalability requirements has therefore been the focus in the first pilot phase. Scalability testing has also been done. Monitoring during operations is not handled yet. Apart from participating in the three pilots, we have arranged retrospectives and conducted structured interviews with main stakeholders in all three organizations.</div></div><div id="Sec2" class="Section1 RenderAsSection1"><h2 class="Heading"><span class="HeadingNumber">2 </span>The ScrumScale Method</h2><div id="Par10" class="Para">With the ScrumScale Method, we seek to combine scalability concerns with agility, and so we work with scalability earlier in the development cycle than what is normally the case, as illustrated in Fig. <span class="InternalRef"><a href="#Fig1">1</a></span>.<div class="Figure" id="Fig1"><div class="MediaObject" id="MO1"><img src="A468350_1_En_17_Fig1_HTML.gif" alt="A468350_1_En_17_Fig1_HTML.gif"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Fig. 1.</span><div class="SimplePara">ScrumScale vision</div></div></div></div>
</div><div id="Par11" class="Para">The ScrumScale Method has the following seven steps for each new product:<div class="OrderedList"><ol><li class="ListItem"><span class="ItemNumber">1.</span><div class="ItemContent"><div><div id="Par12" class="Para">Scalability triage with a rough, intuitive expert evaluation and feedback</div></div></div><div class="ClearBoth"> </div></li><li class="ListItem"><span class="ItemNumber">2.</span><div class="ItemContent"><div><div id="Par13" class="Para">Extract business-related scalability requirements to get feedback on them</div></div></div><div class="ClearBoth"> </div></li><li class="ListItem"><span class="ItemNumber">3.</span><div class="ItemContent"><div><div id="Par14" class="Para">Derive testable scalability requirements to get feedback on them</div></div></div><div class="ClearBoth"> </div></li><li class="ListItem"><span class="ItemNumber">4.</span><div class="ItemContent"><div><div id="Par15" class="Para">Expert evaluation to get feedback on solution suggestions</div></div></div><div class="ClearBoth"> </div></li><li class="ListItem"><span class="ItemNumber">5.</span><div class="ItemContent"><div><div id="Par16" class="Para">Code review to get feedback on implementation</div></div></div><div class="ClearBoth"> </div></li><li class="ListItem"><span class="ItemNumber">6.</span><div class="ItemContent"><div><div id="Par17" class="Para">Scalability testing to get feedback on solution</div></div></div><div class="ClearBoth"> </div></li><li class="ListItem"><span class="ItemNumber">7.</span><div class="ItemContent"><div><div id="Par18" class="Para">Exploit monitoring data to improve the solution but also to get feedback on the actual workload</div></div></div><div class="ClearBoth"> </div></li></ol></div>
</div><div id="Par19" class="Para">In all these steps, we get feedback, so they are applied iteratively and lend themselves to integration in an agile development process, such as Scrum. In fact, this integration is driven by both sides: Modern, agile practice calls for scalability to be handled likewise, but scalability also will benefit from a more light-weight, iterative approach.</div><div id="Par20" class="Para">The product backlog is set up initially where the product owner in collaboration with customers and other stakeholders defines and prioritizes user stories. Some user stories may be associated with scalability concerns. In between each iteration, the product owner may revisit the product backlog to add or change user stories based on the outcome and new knowledge from the previous sprint. If needed, the product owner should include a scalability expert (champion) to evaluate whether a new or changed story will impact the scalability of the solution. This evaluation may be supported by scalability testing and monitoring of the solution as it is so far. Likewise, a scalability expert may also assist the team that creates code to implement user stories. Sprints are short and time-boxed work periods, typically 2–4 weeks, where scalability is evaluated as part of the sprint review and the planning of the next sprint.</div><div id="Par21" class="Para">For code review (step 5) and monitoring (step 7) we build on existing practices. The other five steps are described in more detail below.</div><div id="Sec3" class="Section2 RenderAsSection2"><h3 class="Heading"><span class="HeadingNumber">2.1 </span>Scalability Triage</h3><div id="Par22" class="Para">This is a fast and informal step where scalability experts try to answer the question: Are there scalability risks associated with the product? Work, load, and quality thresholds are not analyzed explicitly. Therefore, this step requires extensive experience. Features dealing with GUI or adding small details to an otherwise large computation will probably not pose a threat to scalability. Only for features where there may be a threat to scalability will we go further in the ScrumScale Method, where we start by working with the scalability requirements. For the remainder of the features, we simply stop here. This is important, since the remainder of the steps, even though they are lightweight, involve some effort.</div></div><div id="Sec4" class="Section2 RenderAsSection2"><h3 class="Heading"><span class="HeadingNumber">2.2 </span>Extract Business-Related Requirements</h3><div id="Par23" class="Para">Like other product requirements, scalability requirements originate from business goals: What is the ambition and planned roadmap for the product? The first step in scalability requirements elicitation is therefore, to engage product management and ask questions such as:<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div id="Par24" class="Para">What is the total number of users we want to support?</div></li><li><div id="Par25" class="Para">What types of users (roles) are there: the public, administrators, specialists, etc.</div></li><li><div id="Par26" class="Para">What is the total number of objects the system should be able to handle (such as the number of books in an on-line book store)?</div></li><li><div id="Par27" class="Para">What are good quality metrics? Is a 90-percentile response time metric useful?</div></li><li><div id="Par28" class="Para">What are expected magnitudes of quality thresholds –0.1 s, 1 s, 10 s, 1 min, 1 h, 1 day, etc.?</div></li><li><div id="Par29" class="Para">What is the time horizon for the scalability requirements? Is there a planned ramp-up of user load or objects handled? A time horizon larger than five years is probably too much, but shorter than two years probably too small.</div></li></ul></div>
</div><div id="Par30" class="Para">Product owners may also have an idea of the expected operating cost of the system in terms of hardware and software license cost per user, per transaction, or similar. If this is clear, it is recorded at this stage, but it cannot be validated until fairly late in the process when resource demands become understood [<cite><a href="#CR2">2</a></cite>].</div><div id="Par31" class="Para">The requirements gathered at this stage are often imprecise, and not always consistent or even relevant, but they capture the stakeholders’ expectations in a language that they are comfortable with. The next step is to analyze this input and derive precise, useful and testable scalability requirements.</div></div><div id="Sec5" class="Section2 RenderAsSection2"><h3 class="Heading"><span class="HeadingNumber">2.3 </span>Derive Testable Scalability Requirements</h3><div id="Par32" class="Para">To derive systematic, testable requirements, we build on the conceptual model in [<cite><a href="#CR4">4</a></cite>] which is used to understand scalability requirements in [<cite><a href="#CR3">3</a></cite>]. The <span class="EmphasisTypeItalic">system boundaries</span> define which services are included when measuring quality metrics. An <span class="EmphasisTypeItalic">operation</span> defines a unique and relatively similar way of interacting with a service. A <span class="EmphasisTypeItalic">quality metric</span> defines how we measure a certain quality and is a key part of an SLA (service-level agreement). At an overall level, response times and throughput are traditional scalability quality metrics, but more details are required. Is it average or 90 percentile response times? <span class="EmphasisTypeItalic">Quality thresholds (QTs)</span> describe the border between acceptable and non-acceptable quality for each operation and is connected to a particular quality metric. With the 90-percentile response time quality metric some operations may have a 0.1 s quality thresholds, while the threshold is 10 s for other operations.</div><div id="Par33" class="Para ParaOneEmphasisChild"><span class="EmphasisTypeItalic">Load</span> is how often an operation is invoked. In a closed system, load is specified by the number of users (N) and the think time (Z). Since no users enter or leave the system, the number of users is constant. Think time is the average time to compose operation invocations to the system. For an open system, we use arrival rate (λ), measured in operations per time unit, for example 100 transactions per second. In the context of scalability, we are interested in the highest load, i.e. the load during the busiest hour, week, month, and year in our planning horizon.</div><div id="Par34" class="Para"><span class="EmphasisTypeItalic">Work</span> characterizes the amount of data to be processed, stored or communicated when invoking one operation. Ultimately, work describes the amount of hardware and software resources consumed when invoking one operation. The set of operations is of course an important part of work characterization, but so are also key data objects, like documents and accounts. When considering scalability, we are interested in how the work for one operation varies. This is connected to sizes of objects, e.g. number of documents and the average size of these documents. Such parameters are <span class="EmphasisTypeItalic">work parameters</span>. For scalability, we focus on the highest values of the work parameters. Whereas load typically go up and down during the day, week, and month, work parameters typically only increase.</div><div id="Par35" class="Para">Together, work multiplied by load becomes <span class="EmphasisTypeItalic">workload</span>. The highest workload fulfilling quality thresholds is the <span class="EmphasisTypeItalic">capacity</span> of a system.</div><div id="Par36" class="Para ParaOneEmphasisChild">The <span class="EmphasisTypeItalic">critical operations</span> are the operations where the product of load and work poses a risk of not fulfilling the quality thresholds. Of course, it would be beneficial to establish the critical operations early, but this set is also a result of the analysis. Therefore, iterations, a strong point in agile methods, are required.</div><div id="Par37" class="Para">As more knowledge is gained, the granularity may increase or decrease, when operations are split or merged, more work parameters are introduced, or the quality thresholds are defined for each individual operation instead of the same threshold for several operations [<cite><a href="#CR2">2</a></cite>]. The system boundary may also change. However, as we learn more, we see what we can simplify and leave out. This is a typical modeling experience where the granularity (size) of the model increases because of increased understanding before it decreases, when we understand what really matters.</div><div id="Par38" class="Para">At this step, it is useful to get information on the technical approach: system type (e.g. three-tier web application or batch application) and platform (e.g. cloud).</div></div><div id="Sec6" class="Section2 RenderAsSection2"><h3 class="Heading"><span class="HeadingNumber">2.4 </span>Expert Evaluation</h3><div id="Par39" class="Para">The most important outcome of this light-weight expert evaluation is advice on good design decisions and the identification of problem areas when systems are built step by step. This will be part of the planning process and also give input to defining testable scalability requirements, and it will only be performed for high-risk projects. Performance patterns and anti-patterns are explicit and well-documented examples of this knowledge [<cite><a href="#CR7">7</a></cite>], but experts have “silent” knowledge much beyond this. The experts will try to answer the question “Will the product of work and load pose a threat to the quality thresholds?” This can have two outcomes: (1) No risk. (2) Potential risk so that more investigation is required.</div><div id="Par40" class="Para">Scalability experts (champions) will be a limited resource in all organizations. Therefore, one scalability expert will assist several teams and in this way transfer experience across many different projects and technologies.</div></div><div id="Sec7" class="Section2 RenderAsSection2"><h3 class="Heading"><span class="HeadingNumber">2.5 </span>Scalability Testing</h3><div id="Par41" class="Para">During scalability testing, we have partial information across many dimensions:<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div id="Par42" class="Para">Solution: Only some increments are completed.</div></li><li><div id="Par43" class="Para">Test hardware: May not be as powerful as the production hardware.</div></li><li><div id="Par44" class="Para">Test software: The versions may not resemble the production environment.</div></li><li><div id="Par45" class="Para">Test data: Synthetic test data may not represent the details which make scalability hard. Real data may be used, after obfuscation.</div></li><li><div id="Par46" class="Para">Test workload: It may be hard to anticipate all strange usage patterns for real users.</div></li><li><div id="Par47" class="Para">Time to do scalability testing: It is clearly a trade-off between how extensive scalability testing can be performed with frequent iterations. A full, frequent scalability test will simply not be feasible. It is an open question how many scalability requirement violations can be detected by a simple automated test.</div></li><li><div id="Par48" class="Para">Partial competence because of less-than perfect knowledge exchange between scalability tester, architects and developer. To participate in the same Scrum team will of course help. Moreover, selecting optimal configuration parameters for software and hardware is challenging.</div></li></ul></div>
</div><div id="Par49" class="Para ParaOneEmphasisChild">As a result, we should also scale the scalability requirements. When only parts of the solution are completed, it cannot consume <span class="EmphasisTypeItalic">the complete</span> quality thresholds. We do not use models for unfinished parts of the system, but some kind of implicit modelling is required to scale the requirements up or down, according to the degree of completeness of the other dimensions. We may, for example, assume that the basic platform takes half of the time, whereas each of ten features share the rest. A system with two features should then consume approximately 60% of the resources compared to a complete product. Moreover, if the database server resembles the production environment, while the application servers and the network are weaker compared to the production environment, it becomes harder.</div></div></div><div id="Sec8" class="Section1 RenderAsSection1"><h2 class="Heading"><span class="HeadingNumber">3 </span>Conclusion</h2><div id="Par50" class="Para">Half-way into the ScrumScale project, we see the contours of a profitable fusion of scalability engineering and agile practices. To lay the foundation for such an approach, we have described a series of method steps that can be applied in an iterative manner, allowing an agile approach to scalability engineering.</div><div id="Par51" class="Para">ScrumScale extends Scrum by connecting functional requirements with scalability requirements to enable evaluation of scalability after each sprint, supported by monitoring and testing. When new sprints are planned detailed design is evaluated with respect to scalability. ScrumScale also adds a new role, the scalability expert, or champion, that supports the team in making the right decisions.</div><div id="Par52" class="Para">We are developing these artefacts iteratively through trials on real pilots in three partner companies. We will continue with more pilots, making the ScrumScale Method a practical tool for agile scalability engineering.</div></div><div class="Acknowledgments"><div class="Heading">Acknowledgements</div><div class="SimplePara">The research leading to these results has received funding from the Norwegian Research Council under grant #256669 (ScrumScale). Tor Erlend Fægri, then in SINTEF Digital, contributed with early ideas for this paper. EVRY, Powel and Altinn contributed with pilots.</div></div><div class="License LicenseSubType-cc-by"><a href="https://creativecommons.org/licenses/by/4.0"><img src="cc-by.png" alt="Creative Commons"/></a><div class="SimplePara">Open Access This chapter is licensed under the terms of the Creative Commons Attribution 4.0 International License (http://creativecommons.org/licenses/by/4.0/), which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license and indicate if changes were made.
The images or other third party material in this book are included in the book's Creative Commons license, unless indicated otherwise in a credit line to the material. If material is not included in the book's Creative Commons license and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder.</div></div><div class="Bibliography" id="Bib1"><div class="Heading">References</div><div class="BibliographyWrapper"><div class="Citation"><div class="CitationNumber">1.</div><div class="CitationContent" id="CR1">Babar, M.A., Brown, A.W., Mistrík, I.: Agile Software Architecture: Aligning Agile Processes and Software Architectures. Newnes, Oxford (2013)</div></div><div class="Citation"><div class="CitationNumber">2.</div><div class="CitationContent" id="CR2">Becker, S., Brataas, G., Lehrig, S.: Engineering Scalable, Elastic, and Cost-Efficient Cloud Computing Applications: The CloudScale Method. Springer, Cham (2017). <span class="ExternalRef"><a href="https://doi.org/10.1007/978-3-319-54286-7"><span class="RefSource">https://​doi.​org/​10.​1007/​978-3-319-54286-7</span></a></span><span class="Occurrences"><span class="Occurrence OccurrenceDOI"><a href="https://doi.org/10.1007/978-3-319-54286-7"><span><span>Crossref</span></span></a></span></span></div></div><div class="Citation"><div class="CitationNumber">3.</div><div class="CitationContent" id="CR3">Brataas, G., Fægri, T.E.: Agile scalability requirements. In: Proceedings of the 8th ACM/SPEC on International Conference on Performance Engineering. ACM (2017)</div></div><div class="Citation"><div class="CitationNumber">4.</div><div class="CitationContent" id="CR4">Brataas, G., Herbst, N., Ivansek, S., Polutnik, J.: Scalability analysis of cloud software services. In: 2017 IEEE International Conference on Autonomic Computing (ICAC). IEEE (2017)</div></div><div class="Citation"><div class="CitationNumber">5.</div><div class="CitationContent" id="CR5">Davison, R.M., Martinsons, M.G., Kock, N.: Principles of canonical action research. Inf. Syst. J. <span class="EmphasisTypeBold">14</span>(1), 65–86 (2004)<span class="Occurrences"><span class="Occurrence OccurrenceDOI"><a href="https://doi.org/10.1111/j.1365-2575.2004.00162.x"><span><span>Crossref</span></span></a></span></span></div></div><div class="Citation"><div class="CitationNumber">6.</div><div class="CitationContent" id="CR6">Herbst, N.R., Kounev, S., Reussner, R.H.: Elasticity in cloud computing: what it is, and what it is not. In: ICAC (2013)</div></div><div class="Citation"><div class="CitationNumber">7.</div><div class="CitationContent" id="CR7">Smith, C.U., Williams, L.G.: Performance Solutions: A Practical Guide to Creating Responsive, Scalable Software. Addison-Wesley, Boston (2001)</div></div></div></div></div></body></html>
